# 死锁

## 概念

### 资源

资源就是在任何时候都**只能被一个进程使用**的任何对象

可剥夺资源: 可以从拥有它的进程中剥夺而不会产生任何副作用 (存储器)

不可剥夺资源: (刻录机)

#### 使用步骤

1. 请求资源
2. 使用资源
3. 释放资源

### 死锁

如果在一个进程集合中的每个进程都在等待只能由该集合中的另一个进程引发的事件，该组进程就被死锁

### 产生条件

* 互斥: ~~每个资源每次只允许一个进程使用或者空闲~~
* 占有和等待: 已占有某些资源的进程可以请求新的资源
* 非剥夺条件: ~~先前授予的资源无法强制地剥夺~~
* 循环等待条件: ~~至少有2个或以上进程构成循环链, 每个进程都在等待由循环链中下一个成员占有的资源~~

#### 死锁建模

\tikz{
    \node[circle, draw] (p) at (0,0) {A};
    \node[rectangle, draw] (r) at (2,0) {R};
    \draw[->] (r) -- (p);
}: 资源R被指派给进程A

\tikz{
    \node[circle, draw] (p) at (0,0) {A};
    \node[rectangle, draw] (r) at (2,0) {R};
    \draw[->] (p) -- (r);
}: 进程A请求/等待资源R

## 鸵鸟算法

即视而不见

*理由:*

* 死锁极少发生
* 预防死锁的代价太高

UNIX和Windows采用这方法,
这是方便性与正确性的平衡

## 死锁检测和恢复

* 允许死锁发生
* 尝试检测并恢复

### 单资源类型的死锁检测

每种资源只可分配一次, ~~每种类型只存在一个资源~~

构造资源图, 检测环路

### 多资源类型的死锁检测

每种资源只可分配多次, ~~每种类型存在多个资源~~

::: {.example}
所有资源$E=(4, 2, 3, 1)$,
可用资源$A=(2, 1, 0, 0)$,\newline
当前分配矩阵$C = \left[ \begin{matrix} 0 & 0 & 1 & 0 \\ 2 & 0 & 0 & 1 \\ 0 & 1 & 2 & 0 \end{matrix} \right]$,
请求矩阵$R = \left[ \begin{matrix} 2 & 0 & 0 & 1 \\ 1 & 0 & 1 & 0 \\ 2 & 1 & 0 & 0 \end{matrix} \right]$

1. 找到P3满足R3=(2 1 0 0)<=A，标记P3并释放其资源：A=A+C3=(2 1 0 0)+(0 1 2 0)=(2 2 2 0)
1. 找到P2满足R2=(1 0 1 0)<=A，标记P2并释放其资源：A=A+C2=(2 0 0 1)+(2 2 2 0)=(4 2 2 1)
1. 找到P1满足R1=(2 0 0 1)<=A，标记P1并释放其资源：A=A+C1=(0 0 1 0)+(4 2 2 1)=(4 2 3 1)

结果: P1、 P2 、P3均被标记，不存在死锁
:::

### 从死锁中恢复

* 剥夺法恢复, 很可能需要人工干预, 取决于资源类型
* 回退法恢复, 需要保存资源映像和资源状态
* 杀死进程法, 环路内环路外, 最好从头再运行没有副作用

## 死锁避免

安全状态
: 从安全状态出发，系统能够确保所有进程都能完成

### 银行家算法

优先选择距最大需求最近的客户

## 死锁预防

### 破坏互斥

某些设备(例如打印机)可以假脱机操作

* 只有打印机守护程序使用打印机资源
* 这样就可以消除打印机死锁

不是所有的设备都可以进行假脱机操作

原则:

* 不到万不得已不要指派资源
* 使得尽可能少的进程实际上要求资源

### 破坏占有和等待

要求进程在开始执行前请求所需资源, 这样进程在其需要时无需等待

问题

* 也许在开始运行时无法确知是否需要资源
* 也许需要的资源其他进程正在使用

变更 

* 进程必须放弃所有资源
* 然后在需要时申请全部所需资源

### 破坏不可剥夺

剥夺, 通常不是有效的

### 破坏循环等待

* 保证每一个进程在任何时刻只能占用一个资源
* 提供所有资源一个全局编号, 所有申请必须按照编号的顺序


<!--
    vi: ft=pandoc.markdown
-->