<!--
    vi: ft=pandoc.markdown
-->

# 进程和线程

程序
: 指令的有序集合

多道程序设计
: CPU在各进程虚拟CPU中来回切换

* 通常高级语言不允许直接访问硬件, 中断处理程序中必须有汇编

<div class="example">
进程与程序区别

1. 程序是指令的有序集合(静态); 进程是程序在处理机上的一次执行过程(动态)
1. 程序可以**长期保存**, 而进程**暂时存在**则是具有生命周期(动态的产生和消亡)
1. 不同的进程可以包含同一程序; 同一程序在执行中也可以产生多个进程
1. 进程包括程序、数据和进程状态信息
</div>

## 进程模型

进程, 顺序进程
: 正在运行的程序, 包括**程序计数器, 寄存器, 变量的当前值**.

* 进程是某种类型的活动。它有**程序、输入、输出、状态**
* 单处理器可以被几个进程所共享，使用某些调度算法

### 特点

* 顺序执行
  * 顺序性
  * 封闭性
  * 可再现性
* 并发
  * 间断（异步）性
  * 失去封闭性
  * 失去可再现性

### 创建

进程创建原因

1. 系统初始化 (init)
2. 正在运行的程序执行了创建进程的系统调用 (fork)
3. 用户请求创建一个新进程 (shell)
4. 一个批处理作业的初始化 (udev?)

守护进程, daemon
: 后台服务

### 终止

1. 正常推出 (eof)
2. 错误推出 (panic)
3. 严重推出 (段错误?)
4. 被其他进程杀死 (KILL)

### 层次结构管理

1. 进程组 (tree)
2. 句柄 (token控制)

### 进程状态

``` {.embed .plantuml width=350}
@startuml
scale 2
hide empty description

state 就绪
运行 --> 阻塞: 等待输入
阻塞 --> 就绪: 出现有效输入
就绪 --> 运行: 调度程序选择这个进程
运行 --> 就绪: 调度进程选择另一个进程
@enduml
```

### 实现

操作系统维护一张**进程表: [进程表项: {程序计数器, 堆栈指针, 内存分配, 打开文件, 帐号, 调度信息}]**

### 多道程序

$\text{CPU利用率} = 1 - p^n$, $p$为I/O等待时间占, $n$称为多道程序道度

## 线程模型

* 操作系统能够进行运算调度的最小单位
* 进程作为资源分配单位
* 同一个地址空间多个控制线程

### 引入原因

1. 并行实体共享同一个地址空间和所有可用数据的能力
1. 比进程更容易创建、撤销
1. 性能的提高, 大量I/O的线程重叠进行, 加快运行
1. 多处理机系统，多线程可以实现真正的并行

## IPC

竞争条件
: 共享数据, 结果取决于运行顺序

临界区
: 对共享内存进行访问的程序片段

### 互斥实现

1. 任何两个进程不能同时处于临界区
1. 不应对CPU的速度和数量做任何假设
1. 临界区外运行的进程不得阻塞其他进程
1. 不得使进程无限期等待进入临界区

#### 忙等待

忙等待
: 连续测试等待

自旋锁
: 用于忙等待的锁

1. 屏蔽中断
1. 锁变量 (非原子)
1. **严格**轮换法, 违反 "临界区外运行的进程不得阻塞其他进程"
1. Peterson解法

   ``` {.python}
   def lock():
       interested[current] = true
       turn = current
       while (turn == current and interested[other] == true):
           pass

   def unlock():
       interested[current] = false
   ```

1. TSL (test and set lock, 原子版锁变量)

#### 协助

::: {.center}
方法 | `wait(semaphore)`{.c} | `signal(semaphore)`
:--:|:--:|:--:
睡眠和唤醒 | `if (EMPTY) sleep(this)`{.c} | `if (NOT_EMPTY) wakeup(process)`{.c}
信号量(原理) | `if (--s < 0) sleep(this)`{.c} | `if (++s <= 0) wakeup(sleeper[0])`{.c}
信号量 | `down((int) semaphore)`{.c} | `up((int) semaphore)`{.c}
Edsger W. Dijkstra | `P((int) semaphore)`{.c} | `V((int) semaphore)`{.c}
mutex | `lock(mutex)`{.c} | `unlock(mutex)`{.c}
:::

## 进程调度

调度程序(算法)
: 多个进程同时竞争CPU, 选择接下来运行的进程

可调度
: 总CPU时间占用率小于1

1. 先来先服务 (fifo)
1. 最短作业优先 (`sort (<)`{.haskell})
1. 最短剩余时间优先 (抢占式最短作业优先)
1. 时间片轮轮转调度
1. 优先级调度
