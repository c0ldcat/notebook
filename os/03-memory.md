<!--
    vi: ft=pandoc.markdown
-->

# 内存管理

``` {.plantuml .embed height=800px}
@startuml
hide empty description

state 存储管理

state 无存储器抽象 {
    state 单一内存
    单一内存 -r-> 保护键: 多线程
    单一内存 --> 连续装载: 多道程序
    单一内存 --> 静态重定位: 多道程序
    连续装载: 易于管理
    静态重定位: 装载时修改地址
}

存储管理 --> 单一内存

state 地址空间 {
    固定分区: 容易实现
    动态重定位: 存储基址, 拦截访问

    state 动态分区 {
        state 管理 {
            位图 --> 链表: 0串搜索耗时
        }
    
        state 分配
        分配: 首次分配, 下次分配,\n最佳适配, 最差适配
    }
    动态分区: 根据程序要求分配
    固定分区 --> 动态分区: 解决内碎片,\n动态并发限制,\n低利用率

    动态分区 --> 内存紧缩: 外碎片(空洞)
    内存紧缩: 每个分区释放后或\n找不到满足条件的空闲分区向前合并.\n开销大

    固定分区 --> 伙伴系统: 动态并发限制,\n低利用率
    动态分区 --> 伙伴系统: 实现复杂,\n开销大

}
地址空间: 分区式管理

连续装载 --> 固定分区: 多进程
静态重定位 --> 动态重定位: 难以区分地址, 缓慢且复杂

地址空间 --> 覆盖技术: 需大于供
覆盖技术: 同一进程内不存在调用关系\n的模块覆盖(*热替换)
覆盖技术 --> 交换技术: 需要编程是划分模块,\n比较麻烦
交换技术: 整个进程空间对换\n(roll-in/roll-out)
@enduml
```

## 无存储器抽象

直接对应物理内存

### 变体

1. 操作系统位于RAM底部
1. 操作系统位于顶部ROM中
1. 设备驱动位于顶部ROM, 操作系统位于RAM底部

### 并行

* 连续装载
* 每个内存块加保护键

#### 重定位

静态重定位, 装载时将偏移量加到进程中可重定位地址上

问题: 与常量混淆判定困难, 解决方案: 地址空间

## 地址空间

动态重定位, 使用**基址寄存器**和**界限寄存器**(可选, 解决保护), 拦截各个进程访问内存指令

