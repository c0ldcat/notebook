<!--
    vi: ft=pandoc.markdown
-->

# 内存管理

``` {.plantuml .embed height=800px}
@startuml
scale 2
hide empty description

state 存储管理

state 无存储器抽象 {
    state 单一内存
    单一内存 -r-> 保护键: 多线程
    单一内存 --> 连续装载: 多道程序
    单一内存 --> 静态重定位: 多道程序
    连续装载: 易于管理
    静态重定位: 装载时修改地址
}

存储管理 --> 单一内存

state 地址空间 {
    固定分区: 容易实现
    动态重定位: 存储基址, 拦截访问

    state 动态分区 {
        state 管理 {
            位图 --> 链表: 0串搜索耗时
        }
    
        state 分配
        分配: 首次分配, 下次分配,\n最佳适配, 最差适配
    }
    动态分区: 根据程序要求分配
    固定分区 --> 动态分区: 解决内碎片,\n动态并发限制,\n低利用率

    动态分区 --> 内存紧缩: 外碎片(空洞)
    内存紧缩: 每个分区释放后或\n找不到满足条件的空闲分区向前合并.\n开销大

    固定分区 --> 伙伴系统: 动态并发限制,\n低利用率
    动态分区 --> 伙伴系统: 实现复杂,\n开销大

}
地址空间: 分区式管理

连续装载 --> 固定分区: 多进程
静态重定位 --> 动态重定位: 难以区分地址, 缓慢且复杂

地址空间 --> 覆盖技术: 需大于供
覆盖技术: 同一进程内不存在调用关系\n的模块覆盖(*热替换)
覆盖技术 --> 交换技术: 需要编程是划分模块,\n比较麻烦
交换技术: 整个进程空间对换\n(roll-in/roll-out)

state 不连续地址空间 {
    state 页式存储管理 {
        state 页面置换算法 {
            state 最优页面置换算法
            最优页面置换算法: 不可实现
            NRU: 最近未使用\n定时清空READ FLAG
            FIFO: 先进先出
            NRU --> 第二次机会: 不定时情况R位
            FIFO --> 第二次机会
            第二次机会 --> 时钟页面置换算法: 移动链表影响效率
            时钟页面置换算法: 循环链表

            LRU: 最近最少使用
            LRU --> NRU: 软实现
            NFU: 最近不常用\nR页自加1
            NRU --> NFU: 记数READ FLAG
            NFU --> 老化算法: 右移计数

            LRU --> 指令计时器: 硬实现
            指令计时器: 64位硬件计数器\n每条指令后自加1\nR页保存计数器
            指令计时器 --> n方阵
            n方阵: R页行设1, 列设0, \n最小行最久未使用

            工作集页面置换算法 --> 工作集时钟页面置换算法: 页表淘汰耗时
            工作集页面置换算法: 解决频繁颠簸
        }
    }

    页式存储管理 --> MMU: 虚拟地址映射\n物理地址
    MMU: 内存管理单元

    state "(软)TLB" as TLB
    TLB: 转换检测缓冲区\nTranslation Lookaside Buffer
    MMU -r-> TLB: 加速分页

    页式存储管理 --> 多级页表: 大内存
    页式存储管理 --> 倒排页表: 大内存
    倒排页表: 页框对应表项

    state 段式存储管理
    state 页段式存储管理
    页式存储管理 --> 页段式存储管理
    段式存储管理 --> 页段式存储管理
}

地址空间 --> 不连续地址空间: 内碎片\n外碎片
固定分区 --> 页式存储管理
动态分区 --> 段式存储管理 
@enduml
```

储器管理程序
: 操作系统中管理存储器层次的部分

## 任务

1. 记录哪些内存在使用，哪些内存是空闲的
1. 在进程需要时为其分配存储空间，在进程使用完毕后释放存储空间
1. 当内存无法装入所有进程时，管理内存和磁盘间的交换

## 无存储器抽象

直接对应物理内存

### 变体

1. 操作系统位于RAM底部
1. 操作系统位于顶部ROM中
1. 设备驱动位于顶部ROM, 操作系统位于RAM底部

## 地址空间

地址空间(逻辑地址)
: 源程序经编译后目标程序所在的一个地址范围，通常从0开始

存储空间(物理地址)
: 内存中的物理存储单元的集合

动态重定位
: 使用**基址寄存器**和**界限寄存器**(可选, 解决保护), 拦截各个进程访问内存指令

## 交换

把一个进程完整地调入内存，使该进程运行一段时间，然后把它存回磁盘

## 虚拟内存

程序、数据和堆栈的总量可能超过可用的物理内存的大小。操作系统把程序当前使用的部分保留在内存中，而把其他部分保存在磁盘上

## 分页

内存管理单元(MMU)
: 将虚拟地址映射为物理地址