---
# vi: ft=pandoc.markdown
---

# 事务管理

`事务`{.idx}

所谓事务是用户定义的一个数据库操作序列, 这些操作要么全做, 要么全不做, 是一个不可分割的工作单位

## 事务的ACID性质

`ACID`{.idx}
`ACID!原子性`{.idx}
`ACID!一致性`{.idx}
`ACID!隔离性`{.idx}
`ACID!持续性`{.idx}

1. 原子性: 事务中包含的数据库操作要么都做, 要么都不做。这一性质即使在系统发生各种故障之后仍能得到保证
1. 一致性(正确性): 保证事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态
1. 隔离性: 一个事务内部的操作及使用的数据对其他并发事务是隔离的, 并发执行的各个事务之间不能互相干扰, 即每个事务都感觉不到系统中有其他事务在并发地执行
1. 持续性: 一个事务一旦提交, 它对数据库中数据的改变就应该是永久性的, 接下来的其他操作或故障不应该对其执行结果有任何影响

## 并发控制

`并发控制`{.idx}

并发执行的好处
: 提高吞吐量和资源利用率

### 并发操作与数据的不一致性

破坏事务的隔离性

1. 丢失修改

    | T1 | T2 |
    |:---:|:---:|
    | 读A = 20 | |
    | | 读A = 20 |
    | A = A - 1 | |
    | 写回A = 19 | |
    | | A = A - 1 |
    | | 写回A = 19 |

1. 读\`脏'数据

    | T1 | T2 |
    |:---:|:---:|
    | 读A = 50 | |
    | A = A - 30 | |
    | 写回A = 20 | |
    | | 读 A = 20 |
    | ROLLBACK | |
    | A恢复50 | |

1. 不可重复读

    | T1 | T2 |
    |:---:|:---:|
    | 读A = 30 | |
    | 读B = 50 | |
    | 求和 = 80 | |
    | | 读B = 50 |
    | | 读B = B - 30 |
    | | 写回B = 20 |
    | 读A = 30 | |
    | 读B = 20 | |
    | 求和 = 50 | |

1. (幻影现象), 后两者

    1. 事务T1按一定条件从数据库中读取了某些数据记录后, 事务T2删除了其中部分记录, 当T1再次按相同条件读取数据时, 发现某些记录消失了
    2. 事务T1按一定条件从数据库中读取某些数据记录后, 事务T2插入了一些记录, 当T1再次按相同条件读取数据时, 发现多了一些记录

### 可串行化调度

`可串行化`{.idx}

多个事务的并发执行是正确的, 当且仅当其结果与按某一顺序串行地执行这些事务时的结果相同, 称这种并发调度为可串行化调度. 一个给定的并发调度, 当且仅当它是可串行化的, 才认为是正确调度

### 封锁及封锁协议

封锁
: 事务T在对某个数据对象(如表, 记录等)操作之前, 先向系统发出请求, 对其加锁. 加锁后事务T就对该数据对象有了一定的控制

#### 封锁类型

`排他锁`{.idx} `X锁`{.idx} `写锁`{.idx} `共享锁`{.idx} `S锁`{.idx} `读锁`{.idx} 
排他锁(X锁)(写锁), 共享锁(S锁)(读锁)

#### 封锁协议

1. 一级封锁协议(防止丢失修改): 在修改数据R前必须加X锁, 直到事务结束释放
1. 二级封锁协议(防止读\`脏'数据): 一级+读R前加S锁, 读完放
1. 三级封锁协议(防止不可重复读): 一级+读R前加S锁, 事务结束放

#### 死锁

死锁就是两个或多个事务竞争对相同资源的控制权而相互无限制的等待. 预防死锁的方法通常有一次封锁法和顺序封锁法两种. 诊断死锁的方法通常有超时法和事务等待图法两种. 并发控制机制检测到系统中存在死锁后就要设法解除. 通常采用的方法是选择一个处理死锁代价最小的事务, 将其撤消, 释放此事务持有的所有的锁, 使其它事务能继续运行下去

### 两端锁协议

* 在对任何数据进行读, 写操作之前, 事务首先要申请并获得对该数据的封锁
* 在释放一个封锁之后, 事务不再申请和获得任何其他封锁

### 锁的粒度

封锁粒度与系统的并发度和并发控制的开销密切相关. 封锁的粒度越大, 数据库所能够封锁的数据单元就越少, 并发度就越小, 系统开销也越小；反之, 封锁的粒度越小, 并发度较高, 但系统开销也就越大. 如果在一个系统中同时支持多种封锁粒度供不同的事务选择是比较理想的, 这种封锁方法称为多粒度封锁. 通过选择适当的封锁粒度来平衡封锁开销和并发度两个因素, 以求得最优的效果

#### 意向锁

意向锁的含义是如果对一个结点加意向锁, 则说明该结点的下层结点正在被加锁; 对任一结点加锁时, 必须先对它的上层结点加意向锁. 如果没有意向锁, 那么系统在对某个数据对象加锁时, 系统要检查该数据对象上有无显式封锁与之冲突; 再检查其所有上级结点, 看本事务的显式封锁是否与该数据对象上的隐式封锁冲突; 还要检查其所有下级结点, 看它们的显式封锁是否与本事务的隐式封锁冲突. 显然, 这样的检查方法效率很低. 引进意向锁后, DBMS就无需逐个检查下级结点的显式封锁, 提高了对某个数据对象加锁时系统的检查效率

1. IS锁：如果对一个数据对象加IS锁, 表示它的后裔结点拟(意向)加S锁
2. IX锁：如果对一个数据对象加IX锁, 表示它的后裔结点拟(意向)加X锁
3. SIX锁：如果对一个数据对象加SIX锁, 表示对它加S锁, 再加IX锁, 即SIX = S + IX

## 数据库恢复

## 备份技术

### 数据库备份

静态转储方法
: 优点是转储得到的一定是一个数据一致性的副本, 缺点是转储期间不允许有对数据库的任何存取或修改活动

动态转储方法
: 优缺点正好与静态转储相反, 也建议在系统不繁忙时备份

海量转储方法
: 优点是得到的后备副本进行恢复往往更方便，缺点是耗时耗存储空间

增量转储方法
: 优缺点正好与海量转储相反

### 登录日志备份

日志文件是用来记录事务对数据库的更新操作的文件. 如果没有日志文件就不能将数据库恢复到动态转储结束时刻的一致性状态, 更不能恢复到故障发生前某一时刻的一致性状态. 有了日志文件后, 首先由DBA重装数据库后备副本, 将数据库恢复至转储结束时刻的状态(数据库未被破坏这一步不要做), 然后利用日志把自转储结束时刻～故障发生时刻所有已完成的事务进行重做处理, 所有未完成的事务进行撤销处理, 即可把数据库恢复到故障发生前某一时刻的正确状态

#### 登录日志文件的基本原则

1. 登录的次序严格按并行事务执行的事件次序
1. 必须先写日志文件, 后写数据库

    原因: 防止无记录操作

## 恢复技术

### 事务故障恢复

事务故障不破坏数据库, 但破坏了事务的原子性, 造成了数据的不一致性

事务故障的恢复策略是对发生事务故障的事务进行撤销(UNDO)处理

### 系统故障恢复

系统故障不破坏数据库, 但破坏了事务的原子性和持续性, 造成了数据的不一致性

系统故障的恢复策略是强行撤销所有未完成的事务, 让所有非正常终止的事务回滚, 清除它们对数据库的所有修改; 同时还需要重做(REDO)所有已提交的事务, 将已完成事务提交的结果写入数据库, 将数据库恢复到一致状态

### 介质故障恢复

介质故障破坏了数据库本身, 也破坏了事务的原子性和持续性o

事务故障的恢复策略是对发生事务故障的事务进行撤销(UNDO)处理. 系统故障的恢复策略是强行撤销所有未完成的事务, 让所有非正常终止的事务回滚, 清除它们对数据库的所有修改; 同时还需要重做(REDO)所有已提交的事务, 将已完成事务提交的结果写入数据库, 将数据库恢复到一致状态. 介质故障的恢复策略是重装数据库, 再重做已完成的事务

发生故障时, 一方面一些尚未完成的事务对数据库的更新可能已写入磁盘上的物理数据库, 另一方面有些已完成的事务对数据库的更新可能有一部分甚至全部还留在缓冲区, 尚未写入磁盘上的物理数据库, 故障使得缓冲区中的内容都被丢失. 所以对没有提交的事务要UNDO, 对提交的事务要REDO

## 检查点恢复技术

利用日志技术进行数据库恢复时, 恢复子系统需要检查所有日志记录, 确定哪些事务要重做, 哪些事务要撤销. 这样做会带来两个问题, 一是搜索整个日志将花费大量的时间, 二是很多需要重做处理的事务实际上已经将它们的更新操作结果写到了数据库中, 然而恢复子系统又重新执行了这些操作, 浪费了大量时间. 使用检查点方法可以改善恢复效率, 因为该方法保证在检查点之前提交的事务对数据库的修改一定都已写入数据库, 进行恢复处理时, 没有必要对这些事务做重做操作
